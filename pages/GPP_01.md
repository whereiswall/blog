# Game Programming Patterns
## 1. 介绍
	
游戏开发特征： 
* 开发周期紧张 
* 需求容易更改
* 需要团队合作 
* BUG会摧毁产品
	
设计模式的作用： 
* 不要重复造轮子（代码重用）
* 游戏系统的设计目标大致相同
		
游戏一般的设计主题：
* 即时和顺序 —— 在正确的时间以正确顺序发生正确的事情
* 开发周期 —— 高压、大团队协作
* 交互 —— 玩家只看结果，如果各个系统不能完美配合那就是垃圾
* 性能——功能和硬件条件的平衡。没人愿意玩个游戏还得换电脑。
	
## 2. 基础设计模式

Gang of Four的经典设计模式。我们经常讨论的。
	
### Flyweight 

元模式用来解决大量固定重用的对象的设计问题。
简单来说就是制作能够分享的对象。像是Unity中的Material就是在RenderComponent的shareMaterials中的被引用的，多个渲染对象可以引用同一个Material对象。
	
### Singleton 
	
单例是某个类有且只有一个实例，并且我们能全局访问它。
	
单例很容易被滥用，单例存在的问题有：
	
全局访问使得调试变得困难
	
过多耦合
	
没有访问控制
	
单例只能缓解问题，并不能解决问题。
	
在使用单例之前，想想有什么能够代替的方法。例如，只实现全局访问功能可以使用静态方法或变量。只实现类拥有特定个实例，可以通过在私有构造器和静态计数变量来解决。
	
### Command
	
将一个请求封装成一个对象，这样就使得用户可以通过不同的请求来参数化，进而支持undo操作。（但是一般情况下游戏不需要undo操作）
	
这是非常差的定义。GPP一书中说的比较好：命令模式是一种具象化的方法调用。或者说命令是一个将方法调用封装在对象中的模式。GOF也补充过，命令是一种面向对象对回调（callback）的代替。

命令模式的一个好处是，它实际上是间接的。这给了我们更大的灵活性。诸如：
* 允许可配置的控制
* 更改响应我们输入的对象，也包括多个同步对象一起响应。
* 命令可以队列化（例如格斗动作、路径点等）

* 既然命令是对方法的封装，那么我们也可以把RPC callback封装在Net Commamd中，并且可以实现强制实现诸如：Validate方法判断客户端上传的Command是否是作弊的，也可以用来做帧同步。
	
### Observer
	
定义一个一对象对多对象的依赖关系，当一对象改变状态时，依赖他的多对象都能收到通知并自动更新。就是语言用常用的Events。

主要作用有：

* 解耦
** 播放声音
** 处理输入
** 解锁成就
	
### State

允许一个对象在他内部状态改变时，改变他的行为。就好像换了一个类一样。游戏中众多实例表现的不同行为多是基于他们的状态的。

当然我们可以用超多的判断语句野蛮实现，但是这样很快就会失控的。

最简单的state，就是使用枚举类型定义状态，switch语句来决定状态逻辑。

状态模式又优雅又容易维护。它能够封装行为。输入造成的结果是多变的。在状态变化过程中控制主要属性变化。进一步的，状态可以并行也可以分层。这个时候state现在开始向自动机变化。
	
### Prototype
	
原型模式是通过一个原型实例克隆来产生新对象的模式。

他可以避免使用工厂模式产生过多的工厂工具类（Spawner for each class）。也可以避免传统创建对象（new方法）的内部消耗。

#### 实现方法一： 
  
 每个需要原型的类中包含clone方法。进一步的，工厂模式可以再次封装clone方法来实现一个自定义工厂。Unreal UObject->GetDefaultObject 就属于是这种。
 类似于：
···new Spawner（Prototype)->Spawn() => Prototype->clone();···
	
####  方法二：
  
我们能可以将克隆方法封装，而不是将原型对象封装，而保证不用总是需要一哥默认原型对象维护在内存里。类似于：
···new Spawner() { spawn = Prototype->clone } ->spawn();···
  
#### 实现方法三：
  
使用模板元能够的减少代码量。类似于：
  
···Spawner<PrototypeClass>->Spawn() => Prototype->Spawn();···
  
#### 一个讨论：
First-class Type 的意思是能否将type当作一般的类。c++中显然是不行的，Unreal C++通过自己的UHT系统实现了基于静态反射的UClass，在Unreal中我们可以很方便的将类型当作对象去使用，甚至这种为c++补强的UClass方法比C#的动态反射系统，更加高效。而一些动态类型语言，如JS，Phython中，我们可以直接使用一个对象的原型，并将它传递。
原型语言，对OOP来说类并不是必须的，Self就是一种基于原型的OOP语言。Self中一个对象有自己的完整信息，而不再需要额外的类来描述它的属性和方法。由于也没有一个类来描述它的父级别，Self在对象中通过添加一个parent属性来完成继承功能。
JavaScript是在Self的精神上发展的。其中var.prototype是最能体现原型设计模式思想的，所有同一类型的var都含有一个prototype对象，更进一步的是prototype对象是动态的，可以动态的添加属性和方法。我们可以把JS的原型思想描述为以下几点：
当我们使用new关键字创建对象时，我们相当于使用构造函数来描述一个类型；
对象的状态（当前对象的属性和方法）储存在自己的对象实例中；
行为（原型的属性和方法）通过原型储存在一个可以被所有这类对象实例分享的独立的原型对象中。
原型在数据建模方面的比较又作用，假如我们使用json为游戏的数据进行建模，我们可以使用原型来降低数据的重复。

## 3. 游戏设计模式
在GOF的基础上建造的。 

### double buffer双缓冲

双缓冲设计模式保证一系列循序操作瞬时或同时发生。

计算机按顺序同步执行任务是昂贵又受限制的。游戏是沉浸式的体验，必须让虚拟环境偶无破绽。

目的：在正在修改时组织让安全区可以接触。
* 图像渲染中使用双缓冲来绘制，一个缓冲区绘制当前帧、一个缓冲区等待下一帧draw call提交。One for Draw，the Other for Blit。
* AI中使用双缓冲负责实例之间的并行交互。
* 数据保护，保护型拷贝能够允许写入第二拷贝区，来防止入侵正在使用的缓冲区。

### Game Loop 游戏循环

将游戏的时间流逝从用户输入和处理器速度中解放出来。Game Loop可能是游戏中最重要的模式。游戏一方面要等待用户的输入一方面要持续运行，所以需要一个循环。这个设计模式是负责让游戏按照特定的速度运行而不受平台的影响，同时还要与当前平台操作系统事件相交互。
	
最简单的Game Loop就是要能跑多快跑多快，慢机器上跑的慢，快机器上跑得快。更好一点的是我们每次运行一圈，记录时间 ，然后补偿回来。这样如果每个平台的时间流逝一样，游戏就会以特定帧率运行。其实就是在处理输入到渲染绘制过程中，update跑够指定补偿的时间。
	
### Update
模拟让一群独立的对象在他们在同一时间开始执行一帧的行为。
为了保证一个游戏对象对其他对象的行为是同步，行为模式必须在主线程游戏循环上。每个游戏对象维护自己的Update，然后在game loop中调用Update方法来顺序执行，这是game loop的扩展。
	
### Composite
	TODO
  
### Component

允许一个实例能够在多个领域展开，各个领域之间是相互独立、不耦合的。
组件模式可以增强代码的重复利用。

###  Subclass Sandbox
	TODO
  
### ByteCode
  TODO
	
### Type Object
	
类型对象，简单来说就是用一个对象来描述类型。主要目的时避免类的膨胀。典型的OOP思想让我们将每个类型都抽象成一个类，而游戏中的类型基本上时非常多的，这让的编码既编译不友好又难以维护。
	
我们用一个类来描述类型，就是TypeObject。它帮助具体的实例来确定自己的类型，可以帮助这些实例在状态和行为上发生变化。

什么时候使用它：
* 我们无法预先直到我们需要多少类型的时候。
* 当你需要动态修改和增加新类型的时候。
		
需要注意的是：类型对象必须手动跟踪。我们没法在像类一样通过编译器来完成继承这种工作。需要自己手动实现。我们必须保证使用类型对象时他们在内存中存在。另一点是，我们很难为每一种类型对象来建立行为。我们可以建立一个行为表（就像函数表），然后让类型对象从中选择自己需要的行为。
	
设计时候的抉择：
* TypeObject是否需要封装？
* A TypeObject封装在非公开成员里。保证TypeObject的复杂度不暴露，实现细节能够最大程度的降低理解难度；另外，使用TypeObject的对象能够通过自身接口，重写TypeObject的接口。问题是我们需要为每个TypeObject要空开的方法，手写函数接口。TypeObject暴露出来的话可以，和其他类交互，能够极大的扩展相关接口和功能。更多的API也提供出来了。
* TypeObject何时创建？
* 是否可以更改Type？
* 支持何种继承？

### Event Queue
TODO
### Service Locator
TODO
### 数据本地化
TODO
### 脏标记
TODO
### 对象池
TODO
### 空间分区
TODO
5 结论

